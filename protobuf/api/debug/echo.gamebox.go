// Code generated by github.com/averak/gamebox/cmd/protoc-gen-gamebox-server. DO NOT EDIT.
// source: api/debug/echo.proto

package debug

import (
	connect "connectrpc.com/connect"
	context "context"
	connect1 "github.com/averak/gamebox/app/infrastructure/connect"
	advice "github.com/averak/gamebox/app/infrastructure/connect/advice"
	custom_option "github.com/averak/gamebox/protobuf/custom_option"
	proto "google.golang.org/protobuf/proto"
)

type gamebox_EchoServiceHandler interface {
	EchoV1(ctx context.Context, req *advice.Request[*EchoServiceEchoV1Request]) (*EchoServiceEchoV1Response, error)
}

func NewEchoServiceHandler(handler gamebox_EchoServiceHandler, adv advice.Advice) gamebox_EchoServiceHandlerImpl {
	service := File_api_debug_echo_proto.Services().ByName("EchoService")
	causes := [1]map[error]*advice.MethodErrDefinition{{}}
	methodOpts := [1]*advice.MethodOption{}
	for i, m := 0, service.Methods(); i < 1; i++ {
		methodOpts[i] = proto.GetExtension(m.Get(i).Options(), custom_option.E_MethodOption).(*advice.MethodOption)
	}
	methodInfo := [1]*advice.MethodInfo{
		advice.NewMethodInfo(methodOpts[0], causes[0]),
	}
	return gamebox_EchoServiceHandlerImpl{handler: handler, advice: adv, methodInfo: methodInfo}
}

type gamebox_EchoServiceHandlerImpl struct {
	handler    gamebox_EchoServiceHandler
	advice     advice.Advice
	methodInfo [1]*advice.MethodInfo
}

func (h gamebox_EchoServiceHandlerImpl) EchoV1(ctx context.Context, req *connect.Request[EchoServiceEchoV1Request]) (*connect.Response[EchoServiceEchoV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[0], h.handler.EchoV1, h.advice)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}
