// Code generated by github.com/averak/gamebox/cmd/protoc-gen-gamebox-server. DO NOT EDIT.
// source: api/game.proto

package api

import (
	connect "connectrpc.com/connect"
	context "context"
	connect1 "github.com/averak/gamebox/app/infrastructure/connect"
	advice "github.com/averak/gamebox/app/infrastructure/connect/advice"
	custom_option "github.com/averak/gamebox/protobuf/custom_option"
	proto "google.golang.org/protobuf/proto"
)

type gamebox_GameServiceHandler interface {
	// ゲームセッションを取得します。
	GetSessionV1(ctx context.Context, req *advice.Request[*GameServiceGetSessionV1Request]) (*GameServiceGetSessionV1Response, error)
	GetSessionV1Errors(errs *GameServiceGetSessionV1Errors)

	// プレイ中のゲームセッションリストを取得します。
	ListPlayingSessionsV1(ctx context.Context, req *advice.Request[*GameServiceListPlayingSessionsV1Request]) (*GameServiceListPlayingSessionsV1Response, error)

	// ゲームを開始します。
	// なお、チート対策のためゲーム終了判定はサーバー側で行います。
	StartPlayingV1(ctx context.Context, req *advice.Request[*GameServiceStartPlayingV1Request]) (*GameServiceStartPlayingV1Response, error)
	StartPlayingV1Errors(errs *GameServiceStartPlayingV1Errors)
}

type GameServiceGetSessionV1Errors struct {
	// The session does not exist.
	RESOURCE_NOT_FOUND *advice.MethodErrDefinition

	causes map[error]*advice.MethodErrDefinition
}

func (e *GameServiceGetSessionV1Errors) Map(from error, to *advice.MethodErrDefinition) {
	e.causes[from] = to
}

type GameServiceStartPlayingV1Errors struct {
	// The wager must be greater than 0.
	ILLEGAL_ARGUMENT *advice.MethodErrDefinition
	// The game does not exist.
	RESOURCE_NOT_FOUND *advice.MethodErrDefinition
	// The game is already being played.
	RESOURCE_CONFLICT *advice.MethodErrDefinition

	causes map[error]*advice.MethodErrDefinition
}

func (e *GameServiceStartPlayingV1Errors) Map(from error, to *advice.MethodErrDefinition) {
	e.causes[from] = to
}

func NewGameServiceHandler(handler gamebox_GameServiceHandler, adv advice.Advice) gamebox_GameServiceHandlerImpl {
	service := File_api_game_proto.Services().ByName("GameService")
	causes := [3]map[error]*advice.MethodErrDefinition{{}, {}, {}}
	methodOpts := [3]*advice.MethodOption{}
	for i, m := 0, service.Methods(); i < 3; i++ {
		methodOpts[i] = proto.GetExtension(m.Get(i).Options(), custom_option.E_MethodOption).(*advice.MethodOption)
	}
	handler.GetSessionV1Errors(&GameServiceGetSessionV1Errors{
		RESOURCE_NOT_FOUND: methodOpts[0].GetMethodErrorDefinitions()[0],
		causes:             causes[0],
	})
	handler.StartPlayingV1Errors(&GameServiceStartPlayingV1Errors{
		ILLEGAL_ARGUMENT:   methodOpts[2].GetMethodErrorDefinitions()[0],
		RESOURCE_NOT_FOUND: methodOpts[2].GetMethodErrorDefinitions()[1],
		RESOURCE_CONFLICT:  methodOpts[2].GetMethodErrorDefinitions()[2],
		causes:             causes[2],
	})
	methodInfo := [3]*advice.MethodInfo{
		advice.NewMethodInfo(methodOpts[0], causes[0]),
		advice.NewMethodInfo(methodOpts[1], causes[1]),
		advice.NewMethodInfo(methodOpts[2], causes[2]),
	}
	return gamebox_GameServiceHandlerImpl{handler: handler, advice: adv, methodInfo: methodInfo}
}

type gamebox_GameServiceHandlerImpl struct {
	handler    gamebox_GameServiceHandler
	advice     advice.Advice
	methodInfo [3]*advice.MethodInfo
}

func (h gamebox_GameServiceHandlerImpl) GetSessionV1(ctx context.Context, req *connect.Request[GameServiceGetSessionV1Request]) (*connect.Response[GameServiceGetSessionV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[0], h.handler.GetSessionV1, h.advice)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}

func (h gamebox_GameServiceHandlerImpl) ListPlayingSessionsV1(ctx context.Context, req *connect.Request[GameServiceListPlayingSessionsV1Request]) (*connect.Response[GameServiceListPlayingSessionsV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[1], h.handler.ListPlayingSessionsV1, h.advice)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}

func (h gamebox_GameServiceHandlerImpl) StartPlayingV1(ctx context.Context, req *connect.Request[GameServiceStartPlayingV1Request]) (*connect.Response[GameServiceStartPlayingV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[2], h.handler.StartPlayingV1, h.advice)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}
